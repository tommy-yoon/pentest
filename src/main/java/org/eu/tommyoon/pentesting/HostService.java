package org.eu.tommyoon.pentesting;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import lombok.Data;

@Data
@Service
public class HostService {
	private static Logger log = LoggerFactory.getLogger(PentestApp.class);

	@Autowired
	Config config;
	
	private Host selectedHost = null;
	private List<Host> hosts = new ArrayList<Host>();
	private boolean isScanned = false;
	private String networkId;
	private int CIDR;

	public void setSelectedHost(Host selectedHost) {
		for (Host host : hosts) {
			host.setSelected(false);
		}
		selectedHost.setSelected(true);
		this.selectedHost = selectedHost;
	}
	
	public void scan(String ipAddress, int CIDR) throws Exception {
		if (PentestApp.isNotIPv4(ipAddress)) {
			System.out.println("ERROR: IP addresses are not in proper format");
			return;
		}

		if (CIDR < 0 || CIDR > 32) {
			System.out.println("ERROR: The value of CIDR should be between 0 and 32");
			return;
		}

		/*
		 * find available hosts
		 */
		ArrayList<String> addresses = null;
		try {
			addresses = findAvailableHosts(ipAddress, CIDR);
		} catch (UnknownHostException e) {
			System.out.println("ERROR: IP addresses are not in proper format");
			return;
		}

		/*
		 * create host per address
		 */
		int index = 0;
		for (String address : addresses) {
			index++;
			// System.out.println(index + " : " + address);
			Host host = new Host(index, address);
			host.setStatus(HostStatusEnum.UP);
			hosts.add(host);
		}

		/**
		 * guess OS
		 */
		for (Host host : hosts) {
			String guessedOS = guessOS(host.getIp());
			if (guessedOS != null) {
				host.setOs(guessedOS);				
			}
		}
		/*
		 * find open ports per IP
		 */
		ExecutorService es = Executors.newFixedThreadPool(config.noOfThreads);
		for (Host host : hosts) {
			/*
			 * port scan from 1 to 65535
			 */
			for (int port = 1; port <= 65535; port++) {
				final int finalPort = port;
//					LOG.info("starting a new task for : " + finalPort);
				es.submit(() -> {
					boolean result = isPortOpen(host.getIp(), finalPort, config.pingTimeout);
					if (result) {
						/*
						 * add the open port number
						 */
						host.getOpenPorts().add(finalPort);
//							System.out.printf("Result for %s : %d is %s \n", host.getIp(), finalPort, result);
					}
				});
			}
		}
		es.shutdown();
		try {
			while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
				// The awaitTermination method will wait indefinitely until all tasks are
				// completed.
				// You can add a loop to perform some other actions or just keep waiting here.
			}
		} catch (InterruptedException e) {
			// Handle the interruption if needed
			Thread.currentThread().interrupt();
		}
		if(hosts.size()>0) {
			setNetworkId(ipAddress);
			sortHostsByIP();
			sortPorts();
			setCIDR(CIDR);
			setScanned(true);
		}
	}

	public String guessOS(String ip) {
		/*
		 * guess using TTL
		 */
		Integer ttl = getTTL(ip);
//		System.out.println("#########");
//		System.out.println("Returned TTL : " + ttl);
		
		if (ttl == null) {
			return null;
		}
		
		switch (ttl) {
		case 63:
		case 64:
			return "Linux/Unix";
		case 127:
		case 128:
			return "Windows";
		default:
			break;
		}
		
		return null;
	}

	public Integer getTTL(String ip) {
		String command;
		String pingResult = "";
		Integer ttl = null;

        if(System.getProperty("os.name").toLowerCase().startsWith("windows")) {
            // For Windows
            command = "ping -n 2 " + ip;
        } else {
            // For Linux and OSX
            command = "ping -c 2 " + ip;
        }
        
        try {
            Runtime r = Runtime.getRuntime();
            Process p = r.exec(command);

            BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
//                System.out.println(inputLine);
                pingResult += inputLine;
            }
            in.close();

        } catch (Exception e) {
//            System.out.println(e);
        	e.printStackTrace();
            return ttl;
        }
        
        // Define a regular expression pattern to match the TTL value
        Pattern pattern = Pattern.compile("TTL=(\\d+)", Pattern.CASE_INSENSITIVE);

        // Use a Matcher to find the TTL value in the ping output
        Matcher matcher = pattern.matcher(pingResult);
        
        if (matcher.find()) {
            // Extract the TTL value
            String ttlString = matcher.group(1);
//            System.out.println("ttlString: " + ttlString);
            ttl = Integer.parseInt(ttlString);
//            System.out.println("TTL: " + ttl);
            return ttl;
        } else {
//            System.out.println("TTL not found in the ping output.");
        }
        
		return ttl;
	}

	private void sortPorts() {
		for (Host host : hosts) {
			host.sortPortsByPortNo();
		}
	}

	private void sortHostsByIP() {
		hosts = hosts.stream().sorted((hostA, hostB) -> hostA.getIp().compareTo(hostB.getIp())).collect(Collectors.toList());
	}

	private boolean isPortOpen(String ip, int port, int timeout) {
		try {
			Socket socket = new Socket();
			socket.connect(new InetSocketAddress(ip, port), timeout);
			socket.close();
			return true;
		} catch (IOException e) {
			return false;
		}
	}

	private ArrayList<String> findAvailableHosts(String ipAddress, int cidr)
			throws UnknownHostException, InterruptedException {
		var addresses = new ArrayList<String>();

		byte[] bytes = InetAddress.getByName(ipAddress).getAddress();
		var ipVal = new BigInteger(1, bytes);

		BigInteger mask = BigInteger.ONE.shiftLeft(32 - cidr).subtract(BigInteger.ONE).not();
		BigInteger network = ipVal.and(mask);
		BigInteger broadcast = network.add(mask.not());

		ExecutorService es = Executors.newFixedThreadPool(config.noOfThreads);
		for (BigInteger ip = network.add(BigInteger.ONE); ip.compareTo(broadcast) < 0; ip = ip.add(BigInteger.ONE)) {
			byte[] ipBytes = ByteBuffer.allocate(4).putInt(ip.intValue()).array();

			InetAddress inet = InetAddress.getByAddress(ipBytes);
			String address = inet.getHostAddress();
			es.submit(() -> {
				try {
					if (inet.isReachable(config.pingTimeout)) {
						System.out.println(address + " is reachable.");
						addresses.add(InetAddress.getByAddress(ipBytes).getHostAddress());
					} else {
//							System.out.println(address + " is not reachable.");
					}
				} catch (IOException e) {
					// nothing to do
//					e.printStackTrace();
				}
			});
		}

		es.shutdown();
		try {
			while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
				// The awaitTermination method will wait indefinitely until all tasks are
				// completed.
				// You can add a loop to perform some other actions or just keep waiting here.
			}
		} catch (InterruptedException e) {
			// Handle the interruption if needed
			Thread.currentThread().interrupt();
		}

		return addresses;
	}

	public void deleteScannedHostList() {
		this.selectedHost = null;
		this.hosts = new ArrayList<Host>();
		this.isScanned = false;
		this.networkId = null;
		this.CIDR = 0;
	}

	// find Host object with a matching IP address with the given IP 
	public Host findSelectedHostByIP(String seletecedIP) {
		log.debug("seletecedIP: "+seletecedIP);
		log.debug("hosts.size: "+hosts.size());
		if (hosts != null && hosts.size() > 0 && seletecedIP != null && !seletecedIP.isBlank()) {
			return hosts.stream().filter(host -> host.getIp().equals(seletecedIP)).findFirst().orElse(null);
		}
		return null;
	}
}
