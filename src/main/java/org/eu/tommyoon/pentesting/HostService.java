package org.eu.tommyoon.pentesting;

import java.io.IOException;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.springframework.stereotype.Service;

import lombok.Data;

@Data
@Service
public class HostService {
	 private ArrayList<Host> hosts = new ArrayList<Host>();
	 private boolean isScanned = false;
	 
	 public void scan(String ipAddress, int CIDR) throws Exception {
			System.out.println("Scanning...");

			if (PentestApp.isNotIPv4(ipAddress)) {
				System.out.println("ERROR: IP addresses are not in proper format");
				return;
			}

			if (CIDR < 0 || CIDR > 32) {
				System.out.println("ERROR: The value of CIDR should be between 0 and 32");
				return;
			}

			/*
			 * find available hosts
			 */
			ArrayList<String> addresses = null;
			try {
				addresses = findAvailableHosts(ipAddress, CIDR);
			} catch (UnknownHostException e) {
				System.out.println("ERROR: IP addresses are not in proper format");
				return;
			}

			/*
			 * create host per address
			 */
			int index = 0;
			for (String address : addresses) {
				index++;
				//System.out.println(index + " : " + address);
				hosts.add(new Host(index, address));
			}

			/*
			 * find open ports per IP
			 */
			ExecutorService es = Executors.newFixedThreadPool(20);
			for (Host host : hosts) {
				/*
				 * port scan from 1 to 65535
				 */
				for (int port = 1; port <= 65535; port++) {
					final int finalPort = port;
//					LOG.info("starting a new task for : " + finalPort);
					es.submit(() -> {
						boolean result = isPortOpen(host.getIp(), finalPort, 20);
						if (result) {
							/*
							 * add the open port number
							 */
							host.getOpenPorts().add(finalPort);
//							System.out.printf("Result for %s : %d is %s \n", host.getIp(), finalPort, result);
						}
					});
				}
			}
			es.shutdown();
			try {
				while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
					// The awaitTermination method will wait indefinitely until all tasks are
					// completed.
					// You can add a loop to perform some other actions or just keep waiting here.
				}
			} catch (InterruptedException e) {
				// Handle the interruption if needed
				Thread.currentThread().interrupt();
			}
			System.out.println("Scanning finised");
			setScanned(true);
		}

		private boolean isPortOpen(String ip, int port, int timeout) {
			try {
				Socket socket = new Socket();
				socket.connect(new InetSocketAddress(ip, port), timeout);
				socket.close();
				return true;
			} catch (IOException e) {
				return false;
			}
		}

		private ArrayList<String> findAvailableHosts(String ipAddress, int cidr)
				throws UnknownHostException, InterruptedException {
			var addresses = new ArrayList<String>();

			byte[] bytes = InetAddress.getByName(ipAddress).getAddress();
			var ipVal = new BigInteger(1, bytes);

			BigInteger mask = BigInteger.ONE.shiftLeft(32 - cidr).subtract(BigInteger.ONE).not();
			BigInteger network = ipVal.and(mask);
			BigInteger broadcast = network.add(mask.not());

			ExecutorService es = Executors.newFixedThreadPool(20);
			for (BigInteger ip = network.add(BigInteger.ONE); ip.compareTo(broadcast) < 0; ip = ip.add(BigInteger.ONE)) {
				byte[] ipBytes = ByteBuffer.allocate(4).putInt(ip.intValue()).array();

				InetAddress inet = InetAddress.getByAddress(ipBytes);
				String address = inet.getHostAddress();
				es.submit(() -> {
					try {
						if (inet.isReachable(20)) {
							System.out.println(address + " is reachable.");
							addresses.add(InetAddress.getByAddress(ipBytes).getHostAddress());
						} else {
//							System.out.println(address + " is not reachable.");
						}
					} catch (IOException e) {
						// nothing to do
//					e.printStackTrace();
					}
				});
			}

			es.shutdown();
			try {
				while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
					// The awaitTermination method will wait indefinitely until all tasks are
					// completed.
					// You can add a loop to perform some other actions or just keep waiting here.
				}
			} catch (InterruptedException e) {
				// Handle the interruption if needed
				Thread.currentThread().interrupt();
			}

			return addresses;
		}
}
