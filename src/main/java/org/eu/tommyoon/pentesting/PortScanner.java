package org.eu.tommyoon.pentesting;

import java.io.IOException;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;

@ShellComponent
public class PortScanner {
	@Autowired
	private HostList hostList;
	
	private static Logger LOG = LoggerFactory.getLogger(Pentest.class);

	@ShellMethod(key={"scan", "s"}, value="Scan available IP addresses and open ports")
	public void scan(String ipAddress, int CIDR) throws Exception {
//		LOG.info("EXECUTING : command line runner");
//		
//		for (int i = 0; i < args.length; ++i) {
//			LOG.info("args[{}]: {}", i, args[i]);
//		}
//		if (args.length < 2) {
//			System.out.println("Usage : <ipaddress> or <ipaddress>/<CIDR>");
//			System.out.println("Example : 192.168.137.2/24");
//			return;
//		}
//		String ipAddress = args[0];
//		int CIDR = 0;
//		try {
//			CIDR = Integer.parseInt(args[1]);
//		} catch (NumberFormatException e) {
//			System.out.println("ERROR: The value of CIDR should be integer");
//			return;
//		}
		if (CIDR <0 && CIDR>32) {
			System.out.println("ERROR: The value of CIDR should be between 0 and 32");
			return;
		}
		
		/*
		 * find available hosts
		 */
		ArrayList<String> addresses = null;
		try {
			addresses = findAvailableHosts(ipAddress, CIDR);
		} catch (UnknownHostException e) {
			System.out.println("ERROR: IP addresses are not in proper format");
			return;
		}

		/*
		 * create host per address
		 */
		int index = 0;
		for (String address : addresses) {
			index++;
			System.out.println(index + " : " + address);
			hostList.getHosts().add(new Host(index, address));
		}

		/*
		 * find open ports per IP
		 */
		ExecutorService es = Executors.newFixedThreadPool(20);
	    for (Host host : hostList.getHosts()) {
			/*
			 * port scan from 1 to 65535
			 */
			for (int port = 1; port <= 65535; port++) {
				final int finalPort = port;
//				LOG.info("starting a new task for : " + finalPort);
				es.submit(() -> {
					boolean result = isPortOpen(host.getIp(), finalPort, 20);
					if (result) {
						/*
						 * add the open port number
						 */
						host.getOpenPorts().add(finalPort);
//						System.out.printf("Result for %s : %d is %s \n", host.getIp(), finalPort, result);
					}
				});
			}
		}
	    es.shutdown();
	    try {
		    while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
		        // The awaitTermination method will wait indefinitely until all tasks are completed.
		        // You can add a loop to perform some other actions or just keep waiting here.
		    }
		} catch (InterruptedException e) {
		    // Handle the interruption if needed
		    Thread.currentThread().interrupt();
		}
	    
	    /*
	     * show result
	     */
	    for (Host host : hostList.getHosts()) {
	    	System.out.printf("Host for %s : \n", host.getIp());
	    	System.out.printf("\tOpen ports : ");						
	    	for (Integer port : host.getOpenPorts()) {
	    		System.out.printf(" %d", port);						
			}
	    	System.out.printf("\n");							    	
		}
	}

	private boolean isPortOpen(String ip, int port, int timeout) {
		try {
			Socket socket = new Socket();
			socket.connect(new InetSocketAddress(ip, port), timeout);
			socket.close();
			return true;
		} catch (IOException e) {
			return false;
		}
	}

	private ArrayList<String> findAvailableHosts(String ipAddress, int cidr) throws UnknownHostException, InterruptedException {
		var addresses = new ArrayList<String>();

		byte[] bytes = InetAddress.getByName(ipAddress).getAddress();
		var ipVal = new BigInteger(1, bytes);

		BigInteger mask = BigInteger.ONE.shiftLeft(32 - cidr).subtract(BigInteger.ONE).not();
		BigInteger network = ipVal.and(mask);
		BigInteger broadcast = network.add(mask.not());

		ExecutorService es = Executors.newFixedThreadPool(20);
		for (BigInteger ip = network.add(BigInteger.ONE); ip.compareTo(broadcast) < 0; ip = ip.add(BigInteger.ONE)) {
			byte[] ipBytes = ByteBuffer.allocate(4).putInt(ip.intValue()).array();
			
			InetAddress inet = InetAddress.getByAddress(ipBytes);
			String address = inet.getHostAddress();
			es.submit(() -> {
				try {
					if (inet.isReachable(20)) {
						System.out.println(address + " is reachable.");
						addresses.add(InetAddress.getByAddress(ipBytes).getHostAddress());
					} else {
//						System.out.println(address + " is not reachable.");
					}
				} catch (IOException e) {
					// nothing to do
//				e.printStackTrace();
				}				
			});
		}
		
		es.shutdown();
		try {
		    while (!es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS)) {
		        // The awaitTermination method will wait indefinitely until all tasks are completed.
		        // You can add a loop to perform some other actions or just keep waiting here.
		    }
		} catch (InterruptedException e) {
		    // Handle the interruption if needed
		    Thread.currentThread().interrupt();
		}
		
		return addresses;
	}
}
