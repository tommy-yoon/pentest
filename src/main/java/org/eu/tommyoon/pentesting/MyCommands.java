package org.eu.tommyoon.pentesting;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.eu.tommyoon.pentesting.host.Host;
import org.eu.tommyoon.pentesting.host.HostService;
import org.eu.tommyoon.pentesting.rpc.MsfRpc;
import org.eu.tommyoon.pentesting.rpc.MsfRpcService;
import org.eu.tommyoon.pentesting.rpc.RpcConnection;
import org.eu.tommyoon.pentesting.rpc.RpcException;
import org.eu.tommyoon.pentesting.rpc.model.RpcServer;
import org.eu.tommyoon.pentesting.shell.Spinner;
import org.jline.terminal.Terminal;
import org.jline.utils.AttributedString;
import org.jline.utils.AttributedStyle;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.shell.Availability;
import org.springframework.shell.command.CommandRegistration;
import org.springframework.shell.component.ConfirmationInput;
import org.springframework.shell.component.SingleItemSelector;
import org.springframework.shell.component.StringInput;
import org.springframework.shell.component.support.SelectorItem;
import org.springframework.shell.jline.PromptProvider;
import org.springframework.shell.result.CommandNotFoundMessageProvider;
import org.springframework.shell.standard.AbstractShellComponent;
import org.springframework.shell.standard.ShellCommandGroup;
import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellMethodAvailability;
import org.springframework.shell.standard.ShellOption;
import org.springframework.shell.style.Theme;
import org.springframework.shell.style.ThemeSettings;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

@Configuration
@ShellComponent
@ShellCommandGroup("Main Commands")
public class MyCommands extends AbstractShellComponent {
	
	@Autowired
	HostService hostService;
	
	@Autowired
	Spinner spinner;
	
//	@Autowired
//	MsfRpc msfRPC;
	
	@Autowired
	private MsfRpcService rpcService;
	
	public MyCommands() throws RpcException {
		super();
//		connectToMSFRPC();
	}

	/*******  Reconnaissance ******/
	/*
	 * find hosts
	 */
	@ShellMethod(key = { "find-hosts", "fh" },  value = "search available IP addresses and open ports. e.g., 192.168.32.0 24", group = "1.Reconnaissance")
	public void scan(@ShellOption(help = "IP address - e.g., 192.168.137.0", defaultValue = "192.168.137.0") 
	String ipAddress, @Min(0) @Max(32)
			@ShellOption(help = "CIDR e.g., 24", defaultValue = "24")
	int CIDR) throws Exception{
//	public void scan(String ipAddress, int CIDR)  throws Exception{
		if (hostService.isScanned()) {
			System.out.println("Scan data exists - use 'list-hosts' or 'lh' command to display or delete first using [delete]");
		} else {
			System.out.println("Start scanning for " + ipAddress + "/" + CIDR);
			spinner.start();
			hostService.scan(ipAddress, CIDR);
			spinner.stop();
			System.out.println("Scanning finished");
			list();
		}
	}
	
	/*
	 * list hosts
	 */
	@ShellMethod(key= {"list-hosts", "lh"}, value="list the available hosts with IP address and open port numbers", group = "1.Reconnaissance")
	public void list() {
		if (!hostService.isScanned()) {
			System.out.println("No available host list found - start scanning using 'find-hosts' or 'fh' command first");
			return;
		}
		List<Host> hosts = hostService.getHosts();
		List<SelectorItem<String>> items = new ArrayList<SelectorItem<String>>();
		for (Host host : hosts) {
			SelectorItem<String> item = SelectorItem.of(
					 Util.displayListInColumns(5, 25, 
					"IP:" + host.getIp(),
					"| OS: " + host.getOs(), 
					"| No of open ports: " + host.getOpenPorts().size(),
					"| selected? : " + host.isSelected(),
					"| exploited? : " + host.isExploited()
					), host.getIp());			
			items.add(item);
		}
		SelectorItem<String> item = SelectorItem.of("Return", "");			
		items.add(item);
		
        SingleItemSelector<String, SelectorItem<String>> component = new SingleItemSelector<>(getTerminal(),
                items, "Choose the target host ", null);
        component.setResourceLoader(getResourceLoader());
        component.setTemplateExecutor(getTemplateExecutor());
        SingleItemSelector.SingleItemSelectorContext<String, SelectorItem<String>> context = component
                .run(SingleItemSelector.SingleItemSelectorContext.empty());
        String seletecedIP = context.getResultItem().flatMap(si -> Optional.ofNullable(si.getItem())).get();
        if (!seletecedIP.isBlank()) {
        	System.out.println("You selected the host : " + seletecedIP);
        	Host host = hostService.findSelectedHostByIP(seletecedIP);
        	hostService.setSelectedHost(host);
        	System.out.println(host);
		}
        
        System.out.println("");
        System.out.println("'vulnerabilites'  or 'v' : search vulnerabilites");
        System.out.println("'exploit'  or 'e' : exploitation");
	}
	
	@ShellMethod(key = {"delete-hosts", "dh"}, value="delete the list of hosts scanned", group = "1.Reconnaissance")
	public void delete() {
		if (!hostService.isScanned()) {
			System.out.println("No available host list to delete");
			return;
		} else {
			ConfirmationInput component = new ConfirmationInput(getTerminal(), "Are you sure to delete the scanned list of available hosts?");
	        component.setResourceLoader(getResourceLoader());
	        component.setTemplateExecutor(getTemplateExecutor());
	        ConfirmationInput.ConfirmationInputContext context = component.run(ConfirmationInput.ConfirmationInputContext.empty());
	        Boolean answer = context.getResultValue();
	        if (answer!=null && answer.booleanValue()) {
	        	System.out.println("Deleting the discovered list of hosts " + hostService.getNetworkId() + "/" + hostService.getCIDR());
//	        	spinner.start();
	        	hostService.deleteScannedHostList();
//	        	spinner.stop();
	        	System.out.println("Deleting finished");				
			}
		}
	}
	
	/****************** Scanning ****************/
	/*
	 * list vulnerabilites
	 */
	@ShellMethod(key= {"list-vulnerabilities", "lv"}, value="List available vulnerabilities ", group = "2.Scanning")
	public void listVulnerabilites() throws RpcException {
		
	}
	/*
	 * find vulnerabilities
	 */
	@ShellMethod(key= {"find-vulnerabilities", "fv"}, value="search vulnerabilities of the selected host", group = "2.Scanning")
	public void searchVulnerabilites() throws RpcException {
		Host selectedHost = hostService.getSelectedHost();
		if (selectedHost == null) {
			System.out.println("No target host is selected. Use 'fh' or 'lh' command first");
			return;
		}
		
		RpcConnection rpcConnection = rpcService.getConnection();
		
		String command = "module.execute";
		String param1 = "auxiliary";
		String param2 = "scanner/http/http_version";
		Map<String, String> arguments = new HashMap<String,String>();
		arguments.put("RHOSTS", selectedHost.getIp());
		
		Object[] params = {param1, param2, arguments};
		Map<?, ?> response = rpcConnection.execute(command, params);
		
		System.out.println(response);
	}
	/*******  Exploitation ******/
	/*******  Post-Exploitation ******/
	/*******  House Cleaning ******/
	
	/*******  ETC. ******/
	@ShellMethod(key = {"list-jobs", "lj"}, value="List current MSF jobs", group = "0.MSFRPC service")
	public void listJobs() throws RpcException {
		RpcConnection rpcConnection = rpcService.getConnection();
		
		Map<?, ?> response = rpcConnection.execute("job.list");
		
		System.out.println(response);
	}
	@ShellMethod(key = {"list-sessions", "ls"}, value="List current MSF sessions", group = "0.MSFRPC service")
	public void listSessions() throws RpcException {
		RpcConnection rpcConnection = rpcService.getConnection();
		
		Map<?, ?> response = rpcConnection.execute("session.list");
		
		System.out.println(response);
	}
	@ShellMethod(key = {"msfrpcd-status", "ms"}, value="Display MSF RPC service info", group = "0.MSFRPC service")
	public void mfcVersion() throws RpcException {
		RpcConnection rpcConnection = rpcService.getConnection();
		
		Map<?, ?> response = rpcConnection.execute("core.version");
		
		System.out.println(response);
		
		response = rpcConnection.execute("core.module_stats");
		
		System.out.println(response);
	}
	
//	@ShellMethodAvailability({"list", "delete"})
//	public Availability listAvailability() {
//        return hostService.isScanned()
//            ? Availability.available()
//            : Availability.unavailable("No scanned data exists");
//    }
}
