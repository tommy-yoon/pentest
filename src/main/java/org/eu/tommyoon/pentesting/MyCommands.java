package org.eu.tommyoon.pentesting;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.eu.tommyoon.pentesting.theming.MyThemeSettings;
import org.jline.terminal.Terminal;
import org.jline.utils.AttributedString;
import org.jline.utils.AttributedStyle;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.shell.Availability;
import org.springframework.shell.command.CommandRegistration;
import org.springframework.shell.component.ConfirmationInput;
import org.springframework.shell.component.SingleItemSelector;
import org.springframework.shell.component.StringInput;
import org.springframework.shell.component.support.SelectorItem;
import org.springframework.shell.jline.PromptProvider;
import org.springframework.shell.result.CommandNotFoundMessageProvider;
import org.springframework.shell.standard.AbstractShellComponent;
import org.springframework.shell.standard.ShellCommandGroup;
import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellMethodAvailability;
import org.springframework.shell.standard.ShellOption;
import org.springframework.shell.style.Theme;
import org.springframework.shell.style.ThemeSettings;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

@Configuration
@ShellComponent
@ShellCommandGroup("Main Commands")
public class MyCommands extends AbstractShellComponent {
	
	@Autowired
	HostService hostService;
	
	@Autowired
	Spinner spinner;
	
//	@Bean
//	CommandRegistration commandRegistration() {
//		return CommandRegistration.builder()
//			.command("mycommand")
//			.target(MyCommands.class)  // Specify the target class
//	        .method("myCommandMethod")  // Specify the target method
//			.build();
//	}
	/*
	 * scanning
	 */
	@ShellMethod(key = { "scan", "s" },  value = "Scan available IP addresses and open ports. e.g., 192.168.32.0 24")
	public void scan(@ShellOption(help = "IP address - e.g., 192.168.137.0", defaultValue = "192.168.137.0") 
	String ipAddress, @Min(0) @Max(32)
			@ShellOption(help = "CIDR e.g., 24", defaultValue = "24")
	int CIDR) throws Exception{
//	public void scan(String ipAddress, int CIDR)  throws Exception{
		if (hostService.isScanned()) {
			System.out.println("Scan data exists - use [list] command to display or delete first using [delete]");
		} else {
			System.out.println("Start scanning for " + ipAddress + "/" + CIDR);
			spinner.start();
			hostService.scan(ipAddress, CIDR);
			spinner.stop();
			System.out.println("Scanning finished");
			list();
		}
	}
	
	/**
	 * list hosts
	 */
	@ShellMethod(key= {"list", "l"}, value="List the available hosts with IP address and open port numbers")
	public void list() {
		if (!hostService.isScanned()) {
			System.out.println("No available host list found - start scanning using [scan] command first");
			return;
		}
		ArrayList<Host> hosts = hostService.getHosts();
		List<SelectorItem<String>> items = new ArrayList<SelectorItem<String>>();
		for (Host host : hosts) {
			SelectorItem<String> item = SelectorItem.of(host.getIp() + " | OS: " + host.getOs() + " | No of open poart: " + host.getOpenPorts().size(), host.getIp());			
			items.add(item);
		}
		SelectorItem<String> item = SelectorItem.of("Return", "");			
		items.add(item);
		
        SingleItemSelector<String, SelectorItem<String>> component = new SingleItemSelector<>(getTerminal(),
                items, "Choose host to perform penetration testing", null);
        component.setResourceLoader(getResourceLoader());
        component.setTemplateExecutor(getTemplateExecutor());
        SingleItemSelector.SingleItemSelectorContext<String, SelectorItem<String>> context = component
                .run(SingleItemSelector.SingleItemSelectorContext.empty());
        String seletecedIP = context.getResultItem().flatMap(si -> Optional.ofNullable(si.getItem())).get();
        if (!seletecedIP.isBlank()) {
        	System.out.println("You selected the host : " + seletecedIP);
        	Host host = hostService.findSelectedHostByIP(seletecedIP);
        	System.out.println(host);
		}
	}
	
	@ShellMethod(key = {"delete", "d"}, value="delete the list of hosts scanned")
	public void delete() {
		if (!hostService.isScanned()) {
			System.out.println("No available host list to delete");
			return;
		} else {
			ConfirmationInput component = new ConfirmationInput(getTerminal(), "Are you sure to delete the scanned list of available hosts?");
	        component.setResourceLoader(getResourceLoader());
	        component.setTemplateExecutor(getTemplateExecutor());
	        ConfirmationInput.ConfirmationInputContext context = component.run(ConfirmationInput.ConfirmationInputContext.empty());
	        Boolean answer = context.getResultValue();
	        if (answer!=null && answer.booleanValue()) {
	        	System.out.println("Deleting the discovered list of hosts " + hostService.getNetworkId() + "/" + hostService.getCIDR());
	        	spinner.start();
	        	hostService.delete();
	        	spinner.stop();
	        	System.out.println("Deleting finished");				
			}
		}
	}
	
//	@ShellMethodAvailability({"list", "delete"})
//	public Availability listAvailability() {
//        return hostService.isScanned()
//            ? Availability.available()
//            : Availability.unavailable("No scanned data exists");
//    }
}
